(this["webpackJsonpyassine-sebri"]=this["webpackJsonpyassine-sebri"]||[]).push([[0],{30:function(e,t,s){},31:function(e,t,s){"use strict";s.r(t);var i=s(1),r=s.n(i),c=s(14),a=s.n(c),o=s(6),n=s(0),d=function(){return Object(n.jsx)("header",{children:Object(n.jsxs)("nav",{children:[Object(n.jsx)(o.b,{to:"/",className:"underline",children:"/About"}),Object(n.jsx)(o.b,{to:"/Projects",className:"underline",children:"/Projects"}),Object(n.jsx)(o.b,{to:"/Blog",className:"underline",children:"/Blog"}),Object(n.jsx)("a",{href:"mailto:yassine.sebri@enetcom.u-sfax.tn ",className:"underline",children:"/Contact"})]})})},b=function(){return Object(n.jsx)("div",{className:"site-title",children:Object(n.jsxs)("h1",{children:["yassine@dev:$",Object(n.jsx)("span",{class:"cursor",children:"\u2588"})]})})},j=s(16),h=s.n(j),l=function(){return Object(n.jsx)(h.a,{options:{loop:!1,delay:65,autoStart:!0,cursor:"\u2588",strings:[""]},onInit:function(e){e.typeString("Hi! <br>").pauseFor(300).typeString(" I'm Yassine,").pauseFor(100).typeString(" a student,").pauseFor(100).typeString(" developer and hacker.<br/>").pauseFor(500).typeString("I love tinkering with different technologies and exploring their inner workings.<br/>").pauseFor(300).typeString("My interests include CTF challenges and competitive programming.<br/>").pauseFor(300).typeString("Feel free to check my work.<br/>")}})},x=function(){return Object(n.jsxs)("footer",{children:[Object(n.jsx)("a",{href:"https://www.linkedin.com/in/yassinesebri/",class:"svglink",target:"__blank",children:Object(n.jsx)("i",{class:"fab fa-linkedin"})}),Object(n.jsx)("a",{href:"https://github.com/Yassine-Sebri/",class:"svglink",target:"__blank",children:Object(n.jsx)("i",{class:"fab fa-github"})}),Object(n.jsx)("a",{href:"https://twitter.com/root0x03",class:"svglink",target:"__blank",children:Object(n.jsx)("i",{class:"fab fa-twitter"})}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"\xa9 Copyright 2021 - Yassine Sebri."]})},p=function(){return Object(n.jsxs)("div",{id:"Writeups",children:["2021-03-05 -"," ",Object(n.jsx)(o.b,{to:"/Blog/Writing-A-Custom-Bootloader",className:"highlight",children:"Writing A Custom Bootloader"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"2021-03-04 -"," ",Object(n.jsx)(o.b,{to:"/Blog/Reverse-Engineering-Camera-Firmware",className:"highlight",children:"Reverse-Engineering A Camera's Firmware"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"2021-03-02 -"," ",Object(n.jsx)(o.b,{to:"/Blog/Microcorruption-Hanoi",className:"highlight",children:"Microcorruption: Hanoi"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"2021-03-01 -"," ",Object(n.jsx)(o.b,{to:"/Blog/Microcorruption-Sydney",className:"highlight",children:"Microcorruption: Sydney"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"2021-02-28 -"," ",Object(n.jsx)(o.b,{to:"/Blog/Microcorruption-New-Orleans",className:"highlight",children:"Microcorruption: New Orleans"})]})},u=s.p+"static/media/NOmain.ae5582a9.png",O=s.p+"static/media/NOcreate.f20144c7.png",m=s.p+"static/media/NOcheck.4df114ba.png",g=s.p+"static/media/NOmemory.5e47a375.png",w=s.p+"static/media/NOsolved.79735ff6.png",f=function(){return Object(n.jsxs)("div",{children:[Object(n.jsx)("br",{}),Object(n.jsx)("h1",{children:"Microcorruption: New Orleans"}),"2021-02-28",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"This will be the first of a series of posts where I detail my answers to various"," ",Object(n.jsx)("a",{href:"https://microcorruption.com/",target:"__blank",children:"microcorruption"})," ","ctf challenges. The objective of these challenges is to unlock a device by reverse-engineering its code and exploiting its vulnerabilities. With that out of the way, let's get hacking!",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The first thing I did was set up a break point at"," ",Object(n.jsx)("span",{id:"code",children:"main"}),", since that's the entry point for our program.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:u,alt:"main"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"This code might seem intimidating if you aren't familiar with assembly, but it's actually quite simple. First, it calls a"," ",Object(n.jsx)("span",{id:"code",children:"create_password"})," function, then it prints a string with the ",Object(n.jsx)("span",{id:"code",children:"puts"})," function. Next, it gets a password from the user and checks if it's correct. Depending on the content of"," ",Object(n.jsx)("span",{id:"code",children:"r15"})," after ",Object(n.jsx)("span",{id:"code",children:"check_password"})," is executed, the door will either unlock or remain locked.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"First of all, Let's take a closer look at"," ",Object(n.jsx)("span",{id:"code",children:"create_password"}),", since it seems like a promising function.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:O,alt:"create_password"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The first instruction seems to be saving a hex number into"," ",Object(n.jsx)("span",{id:"code",children:"r15"})," which will act as a memory address, then it proceeds to move 8 bytes into memory address ",Object(n.jsx)("span",{id:"code",children:"0x2400"})," ","to ",Object(n.jsx)("span",{id:"code",children:"0x2407"}),". it's probably safe to assume that the program will compare this sequence of bytes to the password given by the user later on, but let's follow along for now.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:m,alt:"check_password"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"A quick read through ",Object(n.jsx)("span",{id:"code",children:"check_password"})," shows us that it follows the structure of a while loop, where"," ",Object(n.jsx)("span",{id:"code",children:"r14"})," acts as a counter starting from 0 till it reaches the value 8. ",Object(n.jsx)("span",{id:"code",children:"r14"})," will increment if the bytes at address ",Object(n.jsx)("span",{id:"code",children:"0x2400"})," previously set by the"," ",Object(n.jsx)("span",{id:"code",children:"create_password"})," function match the user input stored at the memory address in r13. if ",Object(n.jsx)("span",{id:"code",children:"r14"})," reaches 8, ",Object(n.jsx)("span",{id:"code",children:"r15"})," receives the value 1 which will then unlock the door.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Knowing that, we just have to enter the string stored"," ",Object(n.jsx)("span",{id:"code",children:"0x2400"})," to solve the challenge. We can copy the string using the Live Memory Dump window.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:g,alt:"Live Memory Dump"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Et voila! It was a pretty straightforward solution meant to familiarize newcomers with reading and understanding assembly code.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:w,alt:"Challenge solved"})]})},y=s.p+"static/media/Smain.95a7407e.png",v=s.p+"static/media/Scheck.e265bc37.png",k=s.p+"static/media/Ssolved.acc97ee8.png",I=function(){return Object(n.jsxs)("div",{children:[Object(n.jsx)("br",{}),Object(n.jsx)("h1",{children:"Microcorruption: Sydney"}),"2021-03-01",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"As usual, let's start by taking a look at the ",Object(n.jsx)("span",{id:"code",children:"main"})," ","function.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:y,alt:"main"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Unlike last time, there doesn't seem to be a"," ",Object(n.jsx)("span",{id:"code",children:"create_password"})," function, but the flow is pretty similar. First it gets a password from the user then it executes the"," ",Object(n.jsx)("span",{id:"code",children:"check_password"})," function, and depending on the value of ",Object(n.jsx)("span",{id:"code",children:"r15"})," after the execution it decides whether to open the lock or not. It seems that the"," ",Object(n.jsx)("span",{id:"code",children:"check_password"})," function is key in this whole thing, so let's check it out.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:v,alt:"check_password"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The ",Object(n.jsx)("span",{id:"code",children:"check_password"})," performs a series of comparisons between the values stored at an offset from memory address"," ",Object(n.jsx)("span",{id:"code",children:"r15"})," and a set of hexadecimal values. If the values match then ",Object(n.jsx)("span",{id:"code",children:"r15"})," would receive the value 1, fulfilling the condition for unlocking the door. The memory values stored at ",Object(n.jsx)("span",{id:"code",children:"r15"})," represent the password entered by the user, so all we have to do to solve the challenge is submit the hexadecimal values found in this function.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),'Submitting the values as is won\'t solve the challenge, however. This challenge was probably designed to teach people about the concepts of "big endian" and "little endian". A big endian system stores the most significant byte of a word at the smallest memory address while a little endian system does the opposite. This might seem a bit confusing but it just means that if you give a 16 bit CPU that uses little endian a value of ',Object(n.jsx)("span",{id:"code",children:"0x4142"}),", for example, it will be stored in memory as ",Object(n.jsx)("span",{id:"code",children:"0x4241"}),".",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"So in order to solve the challenge, we have to invert the hexadecimal values in the ",Object(n.jsx)("span",{id:"code",children:"check_password"})," function two by two. So in this case the password would be (in hexadecimal)"," ",Object(n.jsx)("span",{id:"code",children:"2e3c62496638332b"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:k,alt:"solved"})]})},T=s.p+"static/media/Hmain.a2fe6a4e.png",S=s.p+"static/media/Hlogin.da9bd624.png",N=s.p+"static/media/Htest.f7c05546.png",_=s.p+"static/media/Hsolved.b93ea042.png",C=function(){return Object(n.jsxs)("div",{children:[Object(n.jsx)("br",{}),Object(n.jsx)("h1",{children:"Microcorruption: Hanoi"}),"2021-03-02",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),'This challenge is different from the previous ones because solving it doesn\'t involve finding the "correct" password. This might seem confusing but it will become clear as we try to solve the challenge.',Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"As usual, let us start by checking the ",Object(n.jsx)("span",{id:"code",children:"main"})," ","function.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:T,alt:"main"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"It doesn't seem to have much going on. It just calls a"," ",Object(n.jsx)("span",{id:"code",children:"login"})," function and sets ",Object(n.jsx)("span",{id:"code",children:"r15"})," ","to 0 when it is done. It seems like we have to check"," ",Object(n.jsx)("span",{id:"code",children:"login"})," in order to understand what exactly the program is doing.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:S,alt:"login"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The first part is pretty standard. It asks the user for a password and then stores it at memory address ",Object(n.jsx)("span",{id:"code",children:"0x2400"}),". What's interesting, however, is that it asks for a password between 8 and 16 characters. Keep that in mind because it will be important. Next, it calls a ",Object(n.jsx)("span",{id:"code",children:"test_password_valid"})," function and depending on the value of ",Object(n.jsx)("span",{id:"code",children:"r15"})," after it's executed it decides to skip instruction ",Object(n.jsx)("span",{id:"code",children:"0x445a"})," which sets memory address"," ",Object(n.jsx)("span",{id:"code",children:"0x2410"})," to ",Object(n.jsx)("span",{id:"code",children:"0x17"})," or execute it.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Instruction ",Object(n.jsx)("span",{id:"code",children:"0x455a"})," compares the value at address"," ",Object(n.jsx)("span",{id:"code",children:"0x2410"})," with ",Object(n.jsx)("span",{id:"code",children:"0x28"}),", and depending on the result the door will either unlock or remain closed. In other words, our objective is to somehow change the value of"," ",Object(n.jsx)("span",{id:"code",children:"0x2410"})," to ",Object(n.jsx)("span",{id:"code",children:"0x28"}),". Let's check"," ",Object(n.jsx)("span",{id:"code",children:"test_password_valid"})," for any clues that might help.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:N,alt:"test"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"This function seems to do a lot less than I thought. The most interseting parts for to me were instructions ",Object(n.jsx)("span",{id:"code",children:"0x445c"})," and"," ",Object(n.jsx)("span",{id:"code",children:"0x4472"}),". It's just a very roundabout way of giving"," ",Object(n.jsx)("span",{id:"code",children:"r15"})," the value 0 and I'm not sure if it was just there to confuse players or there is more to it. Either way, after fiddling with it for a while and being unable to figure out what I'm supposed to make out of this function I decided to take a step back and focus on what I need to do.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"To open the door I just need to find a way to set the value of"," ",Object(n.jsx)("span",{id:"code",children:"0x2410"})," to ",Object(n.jsx)("span",{id:"code",children:"0x28"}),". I know that the password I type will be stored at ",Object(n.jsx)("span",{id:"code",children:"0x2400"})," so I can modify the values from there to ",Object(n.jsx)("span",{id:"code",children:"0x240F"})," since the password should be 16 characters long...",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Hold on a second! There are no instructions that check if the password I give is 16 characters long. In other words, all I have to do is"," ",Object(n.jsx)("span",{id:"keyword",children:"overflow"})," the input into the address I need by giving input larger than the expected size.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"I tested the idea by giving a password of 18"," ",Object(n.jsx)("span",{id:"code",children:"0x28"})," and as I thought, it worked. This challenge was particularly fun because not only was it a good way to introduce the foundation for buffer overflows, but it also reminded me of how important it is for a hacker to think outside of the box and not be constrained by expected behavior.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:_,alt:"solved"})]})},A=s.p+"static/media/RECFZIP.00b29b14.png",F=s.p+"static/media/RECFread.fdecaac1.png",M=s.p+"static/media/RECFbin.033e7dba.png",B=s.p+"static/media/RECFdd.7e1e25da.png",E=s.p+"static/media/RECFlzma.f1cf303c.png",W=s.p+"static/media/RECFbin2.52c34a0f.png",L=s.p+"static/media/RECFlzma2.8490c22d.png",R=s.p+"static/media/RECFcpio.2a918efd.png",U=s.p+"static/media/RECFfs.cd304991.png",z=function(){return Object(n.jsxs)("div",{children:[Object(n.jsx)("br",{}),Object(n.jsx)("h1",{children:"Reverse-Engineering A Camera's Firmware"}),"2021-03-04",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"I decided to get into reverse engineering firmware in order to understand how low level components work a bit better. In case you don't know what firmware is, it's a special piece of software that dictates how hardware works. Without firmware, hardware would just be a an assemblage of electronic components lacking purpose.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"To get started, I downloaded the firmware of an old D-Link camera. If you want to follow along, you can download the firmware"," ",Object(n.jsx)("a",{href:"http://legacyfiles.us.dlink.com/DCS-932L/REVA/FIRMWARE/DCS-932L_REVA_FIRMWARE_1.14.04.ZIP",children:"here"}),". With that out of the way, let us get started.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The first step is to unzip the file we have. It seems to contain a pdf file and .bin file.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:A,alt:"Unzipping"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"A quick look at the binary file tells us that it's not human-readable. We can use the ",Object(n.jsx)("span",{id:"keyword",children:"strings"})," command to extract redable words but that won't get us far. We need to find a different method in order to extract information.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:F,alt:"Binary file"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"This is where ",Object(n.jsx)("a",{href:"https://github.com/ReFirmLabs/binwalk",children:"binkwalk"})," ","comes in. It's a fast, easy to use tool for analyzing, reverse engineering, and extracting firmware images. It will parse the file and return a table of content based on what it finds. Let's try running it against our binary.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:M,alt:"binwalk output"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"It seems we were able to get some pretty useful information. At"," ",Object(n.jsx)("span",{id:"code",children:"0x19F70"})," sits a U-Boot string. U-Boot is a popular, open-source bootloader used in embedded devices. A bootloader's job is to load the OS when the device is turned on. At"," ",Object(n.jsx)("span",{id:"code",children:"0x50000"})," we can find the uImage header which contains useful information. This camera seems to use a MIPS CPU and use Linux as an OS. The kernel image uses LZMA compression and it starts at"," ",Object(n.jsx)("span",{id:"code",children:"0x50040"}),". Let's try extracting it!",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"To do that, we will use the ",Object(n.jsx)("span",{id:"keyword",children:"dd"})," command.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:B,alt:"dd"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The ",Object(n.jsx)("span",{id:"keyword",children:"if"})," option stands for input file. The"," ",Object(n.jsx)("span",{id:"keyword",children:"skip"})," option allows you to specify which byte you want to start copying from and ",Object(n.jsx)("span",{id:"keyword",children:"of"})," stands for output file. You probably noticed that I skipped the"," ",Object(n.jsx)("span",{id:"keyword",children:"bs"})," option (which stands for block size) and that's because it would take a while to explain. If you're curious you can just google it but it's not very important for our purposes here. We can check the output file with the ",Object(n.jsx)("span",{id:"keyword",children:"file"})," command and it confirms that it is indeed LZMA compressed data.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Next, we should unpack the output file with the"," ",Object(n.jsx)("span",{id:"keyword",children:"unlzma"})," command.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:E,alt:"unlzma"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"It seems that the decompressed file might be another binary, so let's use binwalk to check it out.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:W,alt:"binwalk output"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"We learn that the camera is using Linux kernel version 2.6, which was released around 15 years ago, even though the image itself is relatively recent. This means that it could potentially be vulnerable to tons of kernel exploits that have been discovered over the years. There is also more LZMA compressed data so let's extract it.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:L,alt:"unlzma"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"It seems we found a cpio archive. Let's extract it!",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:R,alt:"extract cpio archive"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"You can find what these options do with a simple"," ",Object(n.jsx)("span",{id:"keyword",children:"man"})," but I think I should mention that the most critical one is ",Object(n.jsx)("span",{id:"keyword",children:"--no-absolute-filenames"})," because without it you might risk overwriting your root directory.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Et voila! We were able to extract the file system from the firmware, giving us a better chance to understand how exactly this camera works.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:U,alt:"Linux filesystem"})]})},H=s.p+"static/media/vim.accdac26.png",P=s.p+"static/media/nasm.85950c13.png",q=s.p+"static/media/hexdump.761eceee.png",D=s.p+"static/media/qemu.b1e594cd.png",Y=s.p+"static/media/vim2.7180c3f6.png",Z=s.p+"static/media/qemu2.1ab8ab75.png",Q=s.p+"static/media/vim3.7cfa02ad.png",J=s.p+"static/media/qemu3.d6883493.png",K=function(){return Object(n.jsxs)("div",{children:[Object(n.jsx)("br",{}),Object(n.jsx)("h1",{children:"Writing a Custom Bootloader"}),"2021-03-06",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"So I've been planning on writing my own operating system for a while and I think now that I understand the basics of how it all works I should try doing it. It probably won't be easy but hopefully by the end of it I will have a better understanding of how computers do their magic.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Anyway, why did I decide that a bootloader should be the first software I write if I'm going to create an OS? That's because a bootloader is the first program loaded into memory by the BIOS when you boot up a computer. It's the bootloader's job to help the computer find the operating system, though in most cases it just loads a second bootloader because the first one is very limited in size (512 bytes only).",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"We're going to write the program in assembly so we need a tool to translate our instructions to opcode, and"," ",Object(n.jsx)("a",{href:"https://www.nasm.us/",children:"NASM"})," is perfect for that. We're also using ",Object(n.jsx)("a",{href:"https://www.qemu.org/",children:"QEMU"})," to emulate the booting process. With that out of the way, let's try creating our bootloader.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:H,alt:"Bootloader code"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The first thing to do is to make sure that creates code for a CPU in 16 bits mode because all x86 CPUs start in 16 bits mode when reset. The next piece of code is what the CPU is going to execute after the bootloader is loaded in memory. In this case, it's an infinite loop that won't do anything but we'll change that eventually.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Line 8 pads the program with 0s till it reaches byte 510. It does that because our bootloader needs to be 512 bytes in size and end with"," ",Object(n.jsx)("span",{id:"code",children:"0x55aa"}),". The reason why it's"," ",Object(n.jsx)("span",{id:"code",children:"0xaa55"})," in code is that x86 CPUs use little endian notation, so they have to be inversed.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:P,alt:"nasm"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),'Next we "compile" our code with NASM like so. The'," ",Object(n.jsx)("span",{id:"keyword",children:"-f bin"})," option instructs NASM to produce raw machine code rather than a package for linking. We can check the output using the ",Object(n.jsx)("span",{id:"keyword",children:"hexdump"})," command.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:q,alt:"hexdump"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"The file is exaclty what we need it to be. Let's try runnning it using QEMU.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:D,alt:"qemu"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Seems like our binary is working as expected, but It's not doing much. Let's try making it print some text. To do that we will use a"," ",Object(n.jsx)("a",{href:"https://en.wikipedia.org/wiki/BIOS_interrupt_call",children:"BIOS interrupt call"})," ","as follows.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:Y,alt:"Interrupt call"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),'We "compile" our code and run it in QEMU. As we can see, we were able to print a character on screen.',Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:Z,alt:"qemu"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),"Now, let's try something more complicated, like printing some ASCII art on boot. To do that we will need to use more"," ",Object(n.jsx)("a",{href:"https://en.wikipedia.org/wiki/INT_10H",children:"INT 10H"})," functions.",Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:Q,alt:"final program"}),Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),'And done! Now we just have to "compile" our code and run it on QEMU.',Object(n.jsx)("br",{}),Object(n.jsx)("br",{}),Object(n.jsx)("img",{src:J,alt:"final product"})]})},V=s(2);var $=function(){return Object(n.jsx)("div",{className:"App",children:Object(n.jsxs)(o.a,{children:[Object(n.jsxs)("div",{id:"container",children:[Object(n.jsx)(d,{}),Object(n.jsx)(b,{}),Object(n.jsx)(V.a,{path:"/",exact:!0,render:function(e){return Object(n.jsx)("span",{id:"type",children:Object(n.jsx)(l,{})})}}),Object(n.jsx)(V.a,{path:"/Blog",exact:!0,component:p}),Object(n.jsx)(V.a,{path:"/Blog/Microcorruption-New-Orleans",component:f}),Object(n.jsx)(V.a,{path:"/Blog/Microcorruption-Sydney",component:I}),Object(n.jsx)(V.a,{path:"/Blog/Microcorruption-Hanoi",component:C}),Object(n.jsx)(V.a,{path:"/Blog/Reverse-Engineering-Camera-Firmware",component:z}),Object(n.jsx)(V.a,{path:"/Blog/Writing-A-Custom-Bootloader",component:K})]}),Object(n.jsx)(x,{})]})})};s(30);a.a.render(Object(n.jsx)(r.a.StrictMode,{children:Object(n.jsx)($,{})}),document.getElementById("root"))}},[[31,1,2]]]);
//# sourceMappingURL=main.360d7e66.chunk.js.map